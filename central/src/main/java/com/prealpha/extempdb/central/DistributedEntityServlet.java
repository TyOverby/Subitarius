/*
 * DistributedEntityServlet.java
 * Copyright (C) 2011 Meyer Kizner
 * All rights reserved.
 */

package com.prealpha.extempdb.central;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Set;

import javax.persistence.EntityExistsException;
import javax.persistence.EntityManager;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.google.common.base.Function;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import com.google.inject.Provider;
import com.prealpha.extempdb.domain.DistributedEntity;
import com.prealpha.extempdb.domain.DistributedEntityReference;
import com.prealpha.extempdb.domain.DistributedEntityReference.Key;
import com.prealpha.extempdb.domain.DistributedEntityReference_;
import com.prealpha.extempdb.domain.Team;
import com.prealpha.extempdb.domain.User;

/**
 * Provides access to {@link DistributedEntity} objects stored on the server.
 * Access is controlled using the credentials stored by
 * {@link AuthenticationServlet} and by the
 * {@linkplain DistributedEntity#getCreator() creator attribute} on the entities
 * themselves. The {@code GET} method is used to retrieve both the entity list
 * and specific entities, and {@code POST} is used to submit new entities. See
 * the method documentation for details.
 * <p>
 * 
 * The following table shows the controls that are placed on reading and writing
 * entities:
 * <p>
 * 
 * <table border="1">
 * <tr>
 * <th></th>
 * <th colspan="3">Owner</th>
 * </tr>
 * <tr>
 * <th></th>
 * <th>None</th>
 * <th>Same team</th>
 * <th>Other team</th>
 * </tr>
 * <tr>
 * <th>Read</th>
 * <td>Yes</td>
 * <td>Yes</td>
 * <td>No</td>
 * </tr>
 * <tr>
 * <th>Write</th>
 * <td>No</td>
 * <td>Yes</td>
 * <td>No</td>
 * </tr>
 * </table>
 * <p>
 * 
 * <b>This servlet is intended to be secured, and undefined behavior will result
 * if {@link AuthenticationServlet} has not accepted credentials. Use a filter
 * in front of this servlet to guarantee that requests are authorized.</b>
 * 
 * @author Meyer Kizner
 * @see #doGet(HttpServletRequest, HttpServletResponse)
 * @see #doPost(HttpServletRequest, HttpServletResponse)
 * 
 */
/*
 * On the central server, there are actually two tables which can contain
 * distributed entity data. The standard DistributedEntity table has the same
 * schema as the one on the client, but it only stores entities which are
 * generated by the server. At present, this means the ArticleUrl and TagMapping
 * instances generated by the searcher.
 * 
 * The other table is DistributedEntityReference, which is a bit of a hack.
 * Instead of storing entities the "proper" way, they are stored as serialized
 * blobs; a composite key consisting of the team ID and entity hash is used.
 * There are no other columns. The reason for this table is that different teams
 * may create identical entities with different metadata (especially creator).
 * The central server needs to be able to store all these conflicting metadata
 * copies in order to provide the synchronization service. Of course, this comes
 * at the cost of data duplication and less intuitive design. Despite this
 * behavior on the server, it is intended that each client/team only have one
 * copy of the metadata for each entity they own, so the
 * DistributedEntityReference table should not be mapped by the client database.
 * 
 * To confuse you further, copies of the same entity can exist in both tables,
 * for example if a user manually adds an article, and then the searcher
 * automatically finds it the next day. If this occurs, the manually created
 * version is returned in preference to the automatic one. Teams which do not
 * have their own manually created version of the entity will still see the
 * automatic version.
 */
final class DistributedEntityServlet extends HttpServlet {
	private final Provider<EntityManager> entityManagerProvider;

	private final Provider<User> userProvider;

	@Inject
	private DistributedEntityServlet(
			Provider<EntityManager> entityManagerProvider,
			Provider<User> userProvider) {
		this.entityManagerProvider = entityManagerProvider;
		this.userProvider = userProvider;
	}

	/**
	 * Returns either a list of available entities (with hashes) or the
	 * serialized form of a specified entity. For this method, the
	 * {@linkplain HttpServletRequest#getPathInfo() path info} part of the
	 * request URI is used to request specific entities.
	 * <p>
	 * 
	 * If the path info is empty or simply a single slash character, the
	 * response will consist of a list of entity hashes available to the client.
	 * Entities to which the client has no access will not be printed. The list
	 * consists of each hash, as a hexadecimal string, on its own line; the
	 * lines are separated by newline characters only.
	 * <p>
	 * 
	 * If the path info starts with a slash but is followed by a character
	 * string, that string is interpreted as the hash of a requested specific
	 * entity. No validation is attempted on the entity hash. If an accessible
	 * entity is found with the hash, its serialized form is written as the
	 * response body along with status code 200 (OK). Otherwise, status code 404
	 * (not found) is returned to the client.
	 * <p>
	 * 
	 * In any other case (if there is one!), status code 400 (bad request) is
	 * sent.
	 */
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse res)
			throws IOException, ServletException {
		String pathInfo = req.getPathInfo();
		if (pathInfo.isEmpty() || pathInfo.equals("/")) {
			PrintWriter writer = res.getWriter();
			Set<String> hashes = ImmutableSet.copyOf(Iterables.concat(
					fetchClientHashes(), fetchServerHashes()));
			for (String hash : hashes) {
				writer.println(hash);
			}
			writer.flush();
		} else if (pathInfo.startsWith("/")) {
			String hash = pathInfo.substring(1);
			byte[] bytes = fetch(hash);
			if (bytes == null) {
				res.sendError(HttpServletResponse.SC_NOT_FOUND);
			} else {
				OutputStream stream = res.getOutputStream();
				stream.write(bytes);
				stream.flush();
			}
		} else {
			res.sendError(HttpServletResponse.SC_BAD_REQUEST);
		}
	}

	/**
	 * @return an {@code Iterable} of all entity hashes belonging to the logged
	 *         in user's team (from the {@link DistributedEntityReference}
	 *         table)
	 */
	private Iterable<String> fetchClientHashes() {
		EntityManager entityManager = entityManagerProvider.get();
		Team team = userProvider.get().getTeam();

		CriteriaBuilder builder = entityManager.getCriteriaBuilder();
		CriteriaQuery<DistributedEntityReference> criteria = builder
				.createQuery(DistributedEntityReference.class);
		Root<DistributedEntityReference> root = criteria
				.from(DistributedEntityReference.class);
		criteria.where(builder.equal(
				root.get(DistributedEntityReference_.team), team));
		Iterable<DistributedEntityReference> references = entityManager
				.createQuery(criteria).getResultList();

		return Iterables.transform(references,
				new Function<DistributedEntityReference, String>() {
					@Override
					public String apply(DistributedEntityReference input) {
						return input.getKey().getEntityHash();
					}
				});
	}

	/**
	 * @return an {@code Iterable} of all entity hashes from the
	 *         {@link DistributedEntity} table
	 */
	private Iterable<String> fetchServerHashes() {
		EntityManager entityManager = entityManagerProvider.get();

		CriteriaBuilder builder = entityManager.getCriteriaBuilder();
		CriteriaQuery<DistributedEntity> criteria = builder
				.createQuery(DistributedEntity.class);
		Root<DistributedEntity> root = criteria.from(DistributedEntity.class);
		criteria.select(root);
		Iterable<DistributedEntity> entities = entityManager.createQuery(
				criteria).getResultList();

		return Iterables.transform(entities,
				new Function<DistributedEntity, String>() {
					@Override
					public String apply(DistributedEntity input) {
						return input.getHash();
					}
				});
	}

	/**
	 * Fetches a {@code DistributedEntity}'s serialized form from the database
	 * given its hash. If someone on the requesting user's team has already
	 * uploaded an entity with the hash requested, that entity's serialized form
	 * is returned. (In this case, the entity comes from the
	 * {@code DistributedEntityReference} table.) Otherwise, the table of
	 * server-generated entities is checked for the hash, and again the
	 * serialized form of the entity is returned if it exists. If no entity is
	 * found, or if the entity has only been uploaded by other teams,
	 * {@code null} is returned in place of a valid serialized form.
	 * 
	 * @param hash
	 *            the hash of a {@code DistributedEntity}
	 * @return a byte array containing the serialized form of the entity, if it
	 *         exists and the client is authorized to obtain it; otherwise,
	 *         {@code null}
	 * @throws IOException
	 *             if something goes wrong during the serialization process;
	 *             shouldn't happen in practice
	 */
	private byte[] fetch(String hash) throws IOException {
		EntityManager entityManager = entityManagerProvider.get();

		// there could be both client and server entities for a given hash
		// but the client entity takes priority, so we check there first
		Team team = userProvider.get().getTeam();
		Key key = new Key(team.getId(), hash);
		DistributedEntityReference reference = entityManager.find(
				DistributedEntityReference.class, key);
		if (reference != null) {
			return reference.getBlob();
		}

		// now check the server entity table
		DistributedEntity entity = entityManager.find(DistributedEntity.class,
				hash);
		if (entity != null) {
			entityManager.detach(entity);
			return serialize(entity);
		}

		// well, looks like the entity doesn't exist
		return null;
	}

	/**
	 * Allows the client to submit a new client-generated entity for storage on
	 * the server. The serialized form of the entity should be submitted as the
	 * request body. Several checks are made before the entity is committed to
	 * the database.
	 * <p>
	 * 
	 * First of all, it must be possible to successfully deserialize the entity
	 * as a {@code DistributedEntity} instance. If for any reason, the
	 * deserialization process fails, status code 400 (bad request) is returned
	 * to the client.
	 * <p>
	 * 
	 * Next, the server checks that there is not already a copy of this entity
	 * stored on the server which is owned by the same team as the requester.
	 * This should help to signal entity conflicts when they occur. If there is
	 * a conflict, status code 409 (conflict) is returned.
	 * <p>
	 * 
	 * Finally, the entity's creator is validated to ensure a creator from the
	 * same team as the requester is declared. Without this check, it would be
	 * possible to forge an HTTP request to store an entity and attribute it to
	 * someone else entirely. If this test fails, status code 403 (forbidden) is
	 * returned.
	 * <p>
	 * 
	 * If the entity passes all of these tests, it is stored in the database and
	 * status code 201 (created) is returned. If a
	 * {@link #doGet(HttpServletRequest, HttpServletResponse) GET} request is
	 * made with the entity hash in the future by any requester on the same
	 * team, the newly stored entity will be returned in preference to any other
	 * entity with the same hash.
	 */
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse res)
			throws IOException, ServletException {
		EntityManager entityManager = entityManagerProvider.get();
		Team team = userProvider.get().getTeam();

		InputStream stream = req.getInputStream();
		ObjectInputStream ois = new ObjectInputStream(stream);
		try {
			DistributedEntity entity = (DistributedEntity) ois.readObject();
			if (!isSameTeam(entity)) {
				// the entity declared a creator from another team
				res.sendError(HttpServletResponse.SC_FORBIDDEN);
			} else {
				String hash = entity.getHash();
				Key key = new Key(team.getId(), hash);
				DistributedEntityReference reference = new DistributedEntityReference(
						key, serialize(entity));
				entityManager.persist(reference);
				entityManager.flush();
				res.setStatus(HttpServletResponse.SC_CREATED);
			}
		} catch (EntityExistsException eex) {
			res.sendError(HttpServletResponse.SC_CONFLICT);
		} catch (ClassCastException ccx) {
			res.sendError(HttpServletResponse.SC_BAD_REQUEST);
		} catch (ObjectStreamException osx) {
			res.sendError(HttpServletResponse.SC_BAD_REQUEST);
		} catch (ClassNotFoundException cnfx) {
			res.sendError(HttpServletResponse.SC_BAD_REQUEST);
		}
	}

	/**
	 * @param entity
	 *            a {@link DistributedEntity} to test
	 * @return {@code true} if the logged in user's team created this entity,
	 *         {@code false} otherwise (including no creator)
	 */
	private boolean isSameTeam(DistributedEntity entity) {
		User creator = entity.getCreator();
		if (creator != null) {
			Team entityTeam = creator.getTeam();
			Team requestTeam = userProvider.get().getTeam();
			return (entityTeam.equals(requestTeam));
		} else {
			return false;
		}
	}

	/**
	 * @param entity
	 *            an entity to serialize
	 * @return the serialized form of the entity, as a byte array
	 * @throws IOException
	 *             if something goes wrong during the serialization process;
	 *             shouldn't happen in practice
	 */
	private static byte[] serialize(DistributedEntity entity)
			throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		ObjectOutputStream oos = new ObjectOutputStream(baos);
		oos.writeObject(entity);
		oos.flush();
		return baos.toByteArray();
	}
}
